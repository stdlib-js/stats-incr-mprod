{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { isPrimitive as isPositiveInteger } from '@stdlib/assert-is-positive-integer';\nimport isnan from '@stdlib/math-base-assert-is-nan';\nimport isInfinite from '@stdlib/math-base-assert-is-infinite';\nimport { assign as frexp } from '@stdlib/math-base-special-frexp';\nimport ldexp from '@stdlib/math-base-special-ldexp';\nimport Float64Array from '@stdlib/array-float64';\nimport format from '@stdlib/string-format';\n\n\n// FUNCTIONS //\n\n/**\n* Computes an updated product.\n*\n* @private\n* @param {Array} workspace - workspace array\n* @param {Object} acc - accumulated fractional and exponent parts\n* @param {number} x - multiplicative factor\n* @returns {number} product\n*/\nfunction product( workspace, acc, x ) {\n\t// Split the incoming value into a normalized fraction and exponent:\n\tfrexp( x, workspace, 1, 0 );\n\n\t// Update the accumulated fraction:\n\tacc.frac *= workspace[ 0 ];\n\n\t// Update the accumulated exponent:\n\tacc.exp += workspace[ 1 ];\n\n\t// Ensure fraction remains normalized to avoid overflow/underflow...\n\tif ( acc.frac > -0.5 && acc.frac < 0.5 ) {\n\t\tfrexp( acc.frac, workspace, 1, 0 );\n\t\tacc.frac = workspace[ 0 ];\n\t\tacc.exp += workspace[ 1 ];\n\t}\n\treturn ldexp( acc.frac, acc.exp );\n}\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes a moving product.\n*\n* ## Method\n*\n* To avoid overflow/underflow, we store the fractional and exponent parts of intermediate results separately. By keeping a normalized fraction, we prevent underflow/overflow of the fraction. Underflow of the exponent is impossible, as IEEE 754 floating-point exponents are integer values. Overflow of the exponent is possible, but highly unlikely. In the worst case, an intermediate exponent is greater than the minimum safe integer, and adding the exponent of an incoming value does not change the intermediate result. While incorrect, such behavior does not lead to exponent overflow.\n*\n* While intermediate results are largely immune to overflow and not subject to underflow, this does not mean that returned results will never be zero or infinite. In fact, zero (underflow) and infinite (overflow) results may be transient (i.e., infinity followed by a finite number).\n*\n* ## References\n*\n* -   Ueberhuber, Christoph W. 1997. _Numerical Computation 1: Methods, Software, and Analysis_. Springer-Verlag Berlin Heidelberg. doi:[10.1007/978-3-642-59118-1](https://doi.org/10.1007/978-3-642-59118-1).\n*\n* @param {PositiveInteger} W - window size\n* @throws {TypeError} must provide a positive integer\n* @returns {Function} accumulator function\n*\n* @example\n* var accumulator = incrmprod( 3 );\n*\n* var p = accumulator();\n* // returns null\n*\n* p = accumulator( 2.0 );\n* // returns 2.0\n*\n* p = accumulator( -5.0 );\n* // returns -10.0\n*\n* p = accumulator( 3.0 );\n* // returns -30.0\n*\n* p = accumulator( 5.0 );\n* // returns -75.0\n*\n* p = accumulator();\n* // returns -75.0\n*/\nfunction incrmprod( W ) {\n\tvar parts;\n\tvar prod;\n\tvar buf;\n\tvar acc;\n\tvar N;\n\tvar i;\n\tif ( !isPositiveInteger( W ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Must provide a positive integer. Value: `%s`.', W ) );\n\t}\n\tbuf = new Float64Array( W );\n\ti = -1;\n\tN = 0;\n\n\t// Initialize a workspace for `frexp`:\n\tparts = [ 0.0, 0 ];\n\n\t// Initial product is 1.0, which may be split into its fractional and exponent parts (0.5 x 2.0**1 = 1.0):\n\tprod = 1.0;\n\tacc = {};\n\tacc.frac = 0.5;\n\tacc.exp = 1.0;\n\n\treturn accumulator;\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated prodct. If not provided a value, the accumulator function returns the current prodct.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @returns {(number|null)} product or null\n\t*/\n\tfunction accumulator( x ) {\n\t\tvar k;\n\t\tvar v;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn prod;\n\t\t}\n\t\t// Update the index for managing the circular buffer:\n\t\ti = (i+1) % W;\n\n\t\t// Case: incoming value is NaN, the accumulated value is automatically NaN...\n\t\tif ( isnan( x ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tprod = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tN += 1;\n\t\t\tprod = product( parts, acc, x );\n\t\t}\n\t\t// Case: outgoing value is a \"special\" value, and, thus, we need to compute the accumulated value...\n\t\telse if (\n\t\t\tbuf[ i ] === 0.0 ||\n\t\t\tisnan( buf[ i ] ) ||\n\t\t\tisInfinite( buf[ i ] )\n\t\t) {\n\t\t\tN = 1;\n\t\t\tacc.frac = 0.5;\n\t\t\tacc.exp = 1.0;\n\t\t\tproduct( parts, acc, x );\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tif ( k !== i ) {\n\t\t\t\t\tv = buf[ k ];\n\t\t\t\t\tif ( isnan( v ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tprod = NaN;\n\t\t\t\t\t\tbreak; // product is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tN += 1;\n\t\t\t\t\tprod = product( parts, acc, v );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current accumulated value nor the incoming value are NaN, so we need to update the accumulated value...\n\t\telse if ( isnan( prod ) === false ) {\n\t\t\tv = x / buf[ i ];\n\t\t\tprod = product( parts, acc, v );\n\t\t}\n\t\t// Case: the current accumulated value is NaN, so nothing to do until the buffer no longer contains NaN values...\n\t\tbuf[ i ] = x;\n\n\t\treturn prod;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default incrmprod;\n"],"names":["product","workspace","acc","x","frexp","frac","exp","ldexp","incrmprod","W","parts","prod","buf","N","i","isPositiveInteger","TypeError","format","Float64Array","k","v","arguments","length","isnan","NaN","isInfinite"],"mappings":";;2rBA0CA,SAASA,EAASC,EAAWC,EAAKC,GAgBjC,OAdAC,EAAOD,EAAGF,EAAW,EAAG,GAGxBC,EAAIG,MAAQJ,EAAW,GAGvBC,EAAII,KAAOL,EAAW,GAGjBC,EAAIG,MAAQ,IAAOH,EAAIG,KAAO,KAClCD,EAAOF,EAAIG,KAAMJ,EAAW,EAAG,GAC/BC,EAAIG,KAAOJ,EAAW,GACtBC,EAAII,KAAOL,EAAW,IAEhBM,EAAOL,EAAIG,KAAMH,EAAII,IAC7B,CA2CA,SAASE,EAAWC,GACnB,IAAIC,EACAC,EACAC,EACAV,EACAW,EACAC,EACJ,IAAMC,EAAmBN,GACxB,MAAM,IAAIO,UAAWC,EAAQ,kEAAmER,IAejG,OAbAG,EAAM,IAAIM,EAAcT,GACxBK,GAAK,EACLD,EAAI,EAGJH,EAAQ,CAAE,EAAK,GAGfC,EAAO,GACPT,EAAM,CAAA,GACFG,KAAO,GACXH,EAAII,IAAM,EAWV,SAAsBH,GACrB,IAAIgB,EACAC,EACJ,GAA0B,IAArBC,UAAUC,OACd,OAAW,IAANT,EACG,KAEDF,EAMR,GAHAG,GAAKA,EAAE,GAAKL,EAGPc,EAAOpB,GACXU,EAAIJ,EACJE,EAAOa,SAGH,GAAKX,EAAIJ,EACbI,GAAK,EACLF,EAAOX,EAASU,EAAOR,EAAKC,QAGxB,GACS,IAAbS,EAAKE,IACLS,EAAOX,EAAKE,KACZW,EAAYb,EAAKE,KAMjB,IAJAD,EAAI,EACJX,EAAIG,KAAO,GACXH,EAAII,IAAM,EACVN,EAASU,EAAOR,EAAKC,GACfgB,EAAI,EAAGA,EAAIV,EAAGU,IACnB,GAAKA,IAAML,EAAI,CAEd,GADAM,EAAIR,EAAKO,GACJI,EAAOH,GAAM,CACjBP,EAAIJ,EACJE,EAAOa,IACP,KACA,CACDX,GAAK,EACLF,EAAOX,EAASU,EAAOR,EAAKkB,EAC5B,OAIyB,IAAlBG,EAAOZ,KAChBS,EAAIjB,EAAIS,EAAKE,GACbH,EAAOX,EAASU,EAAOR,EAAKkB,IAK7B,OAFAR,EAAKE,GAAMX,EAEJQ,CACP,CACF"}